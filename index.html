<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arkivum</title>
    <!-- Oswald Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome für Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #141414;
            color: white;
            transition: background-color 0.3s ease;
        }
        h1, h2, h3, .nav-link, .filter-btn, #add-button {
            font-family: 'Oswald', sans-serif;
        }
        .container {
            padding: 2rem;
        }
        .nav-link:hover {
            color: #b3b3b3;
        }
        .video-card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
            position: relative;
        }
        .video-card:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        .cover-image {
            width: 100%;
            height: 240px;
            object-fit: cover;
        }
        .cover-placeholder {
            width: 100%;
            height: 240px;
        }
        .add-form, .video-player-view {
            transition: opacity 0.5s ease;
        }
        .message-modal {
            background-color: rgba(0, 0, 0, 0.75);
            z-index: 100;
        }
        .episode-drag-item {
            cursor: grab;
        }
        .delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            transition: background-color 0.2s ease;
            opacity: 0;
            z-index: 20;
        }
        .favorite-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            transition: color 0.2s ease, background-color 0.2s ease;
            z-index: 20;
        }
        .video-card:hover .delete-btn {
            opacity: 1;
        }
        .delete-btn:hover {
            background-color: rgba(229, 9, 20, 0.8);
        }
        .favorite-btn:hover {
            color: #e50914;
            background-color: rgba(255, 255, 255, 0.2);
        }
        .title-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            padding: 1rem;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .video-card:hover .title-overlay {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-[#141414]">

    <!-- Netflix-ähnliche Navigationsleiste -->
    <header class="bg-[#141414] text-white p-4 sticky top-0 z-40 shadow-lg">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-8">
                <h1 class="text-3xl font-bold text-[#e50914]">Arkivum</h1>
                <nav class="hidden md:flex space-x-2 text-sm">
                    <a href="#" class="nav-link px-4 py-2 hover:bg-gray-600 rounded-lg transition-colors duration-200" onclick="showView('gallery-view'); applyFilter('all')"><i class="fas fa-home mr-1"></i>Startseite</a>
                    <a href="#" class="nav-link px-4 py-2 hover:bg-gray-600 rounded-lg transition-colors duration-200" onclick="showView('gallery-view'); applyFilter('serie')"><i class="fas fa-tv mr-1"></i>Serien</a>
                    <a href="#" class="nav-link px-4 py-2 hover:bg-gray-600 rounded-lg transition-colors duration-200" onclick="showView('gallery-view'); applyFilter('film')"><i class="fas fa-film mr-1"></i>Filme</a>
                    <a href="#" class="nav-link px-4 py-2 hover:bg-gray-600 rounded-lg transition-colors duration-200" onclick="showView('gallery-view'); applyFilter('favorites')"><i class="fas fa-heart mr-1"></i>Meine Liste</a>
                </nav>
            </div>
            <div class="flex items-center space-x-4">
                <input type="text" id="search-input" placeholder="Titel, Personen, Genres" class="px-3 py-1 bg-gray-700 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-red-500">
                
                <button id="add-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transition-colors duration-200">
                    <i class="fas fa-plus mr-2"></i>Hinzufügen
                </button>
            </div>
        </div>
    </header>

    <!-- Hauptinhalts-Container -->
    <div id="main-content">
        <!-- Hauptansicht: Videogalerie -->
        <main id="gallery-view" class="container mx-auto mt-8">
            <!-- Filter-Buttons -->
            <div class="flex space-x-4 mb-8">
                <button class="filter-btn px-4 py-2 rounded-full font-bold transition-colors duration-200 bg-red-600 hover:bg-red-700 text-white" data-filter="all"><i class="fas fa-th mr-1"></i>Alle</button>
                <button class="filter-btn px-4 py-2 rounded-full font-bold transition-colors duration-200 bg-gray-700 hover:bg-gray-600 text-white" data-filter="film"><i class="fas fa-film mr-1"></i>Filme</button>
                <button class="filter-btn px-4 py-2 rounded-full font-bold transition-colors duration-200 bg-gray-700 hover:bg-gray-600 text-white" data-filter="serie"><i class="fas fa-tv mr-1"></i>Serien</button>
                <button class="filter-btn px-4 py-2 rounded-full font-bold transition-colors duration-200 bg-gray-700 hover:bg-gray-600 text-white" data-filter="favorites"><i class="fas fa-heart mr-1"></i>Meine Liste</button>
            </div>
            
            <!-- Zuletzt gesehen Sektion -->
            <section id="recently-watched-section" class="mb-10 hidden">
                <h2 class="text-2xl font-semibold mb-4">Zuletzt gesehen</h2>
                <div id="recently-watched-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                </div>
            </section>

            <!-- Videogalerie Sektion -->
            <section>
                <h2 id="gallery-title" class="text-2xl font-semibold mb-4">Alle Medien</h2>
                <div id="video-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                    <!-- Videokarten werden hier dynamisch eingefügt -->
                </div>
            </section>
        </main>
        
        <!-- Formular zum Hinzufügen von Medien (zunächst versteckt) -->
        <div id="add-form" class="hidden fixed inset-0 flex items-center justify-center bg-gray-900 bg-opacity-95 z-50 p-4 overflow-y-auto">
            <div class="bg-gray-800 rounded-lg p-8 w-full max-w-2xl my-auto">
                <h2 class="text-2xl font-bold mb-6 text-center">Neues Medium hinzufügen</h2>
                
                <div class="flex space-x-4 mb-6">
                    <button type="button" id="add-movie-btn" class="flex-1 bg-gray-700 hover:bg-gray-600 rounded-lg p-4 text-center">
                        <i class="fas fa-film text-3xl mb-2"></i>
                        <span class="block">Film hinzufügen</span>
                    </button>
                    <button type="button" id="add-series-btn" class="flex-1 bg-gray-700 hover:bg-gray-600 rounded-lg p-4 text-center">
                        <i class="fas fa-tv text-3xl mb-2"></i>
                        <span class="block">Serie hinzufügen</span>
                    </button>
                </div>

                <form id="media-form" class="space-y-4">
                    <!-- Dateiauswahl für das Vorschaubild -->
                    <div>
                        <label for="cover-input" class="block text-sm font-medium text-gray-400">Vorschaubild hochladen</label>
                        <input type="file" id="cover-input" accept="image/*" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-red-600 file:text-white hover:file:bg-red-700">
                    </div>

                    <div>
                        <label for="media-title" class="block text-sm font-medium text-gray-400">Titel</label>
                        <input type="text" id="media-title" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 p-2 focus:ring-red-500 focus:border-red-500">
                    </div>

                    <!-- Spezieller Bereich für Serien -->
                    <div id="series-section" class="hidden">
                        <h3 class="text-lg font-semibold mt-6 mb-2">Episoden-Reihenfolge (nach Staffeln)</h3>
                        <div id="seasons-container" class="space-y-4">
                            <!-- Staffeln werden hier dynamisch eingefügt -->
                        </div>
                        <button type="button" id="add-season-btn" class="w-full mt-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">
                            <i class="fas fa-plus-circle mr-2"></i>Staffel hinzufügen
                        </button>
                    </div>

                    <!-- Dateiauswahl für Filme -->
                    <div id="movie-files-section">
                        <label for="file-input-movie" class="block text-sm font-medium text-gray-400">Video-Dateien auswählen</label>
                        <input type="file" id="file-input-movie" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-red-600 file:text-white hover:file:bg-red-700" multiple>
                    </div>
                    
                    <div class="flex justify-end space-x-4 mt-6">
                        <button type="button" id="cancel-btn" class="px-4 py-2 text-gray-400 hover:text-white rounded-lg">Abbrechen</button>
                        <button type="submit" class="px-6 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-bold">Speichern</button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Video-Player-Ansicht (zunächst versteckt) -->
        <div id="video-player-view" class="hidden w-full h-full bg-black">
            <button id="back-to-gallery-btn" class="fixed top-4 left-4 z-50 text-white text-3xl hover:text-gray-400">
                <i class="fas fa-arrow-left"></i>
            </button>
            <div id="video-info-overlay" class="fixed bottom-0 left-0 right-0 bg-gradient-to-t from-black to-transparent p-8">
                <h1 id="player-title" class="text-3xl font-bold mb-2"></h1>
                <h2 id="player-subtitle" class="text-xl text-gray-400"></h2>
                <!-- Fortschrittsbalken und Zeit-Anzeige -->
                <div class="flex items-center space-x-4 mt-2">
                    <span id="current-time" class="text-sm">0:00</span>
                    <div id="progress-bar-container" class="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div id="progress-bar" class="h-full bg-red-600" style="width: 0%;"></div>
                    </div>
                    <span id="total-duration" class="text-sm">0:00</span>
                </div>
            </div>
            <video id="player-video" controls class="w-full h-screen object-contain"></video>
        </div>
    </div>
    
    <!-- Lade-, Fehler- und Bestätigungsmodal -->
    <div id="message-modal" class="message-modal fixed inset-0 hidden flex items-center justify-center">
        <div class="bg-gray-800 rounded-lg p-6 max-w-sm text-center shadow-lg">
            <div id="modal-spinner" class="hidden animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-red-500 mx-auto mb-4"></div>
            <p id="modal-message" class="text-lg"></p>
            <div id="modal-buttons" class="hidden mt-4 space-x-4 justify-center">
                <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-bold">Ja, löschen</button>
                <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-lg">Abbrechen</button>
            </div>
            <button id="modal-close-btn" class="mt-4 px-4 py-2 bg-red-600 rounded-lg hidden">Schließen</button>
        </div>
    </div>

    <script>
        // DOM-Elemente
        const mainContent = document.getElementById('main-content');
        const galleryView = document.getElementById('gallery-view');
        const addForm = document.getElementById('add-form');
        const videoPlayerView = document.getElementById('video-player-view');
        const addButton = document.getElementById('add-button');
        const addMovieBtn = document.getElementById('add-movie-btn');
        const addSeriesBtn = document.getElementById('add-series-btn');
        const mediaForm = document.getElementById('media-form');
        const coverInput = document.getElementById('cover-input');
        const mediaTitleInput = document.getElementById('media-title');
        const movieFilesSection = document.getElementById('movie-files-section');
        const fileInputMovie = document.getElementById('file-input-movie');
        const seriesSection = document.getElementById('series-section');
        const seasonsContainer = document.getElementById('seasons-container');
        const addSeasonBtn = document.getElementById('add-season-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        const backBtn = document.getElementById('back-to-gallery-btn');
        const videoContainer = document.getElementById('video-container');
        const playerVideo = document.getElementById('player-video');
        const playerTitle = document.getElementById('player-title');
        const playerSubtitle = document.getElementById('player-subtitle');
        const messageModal = document.getElementById('message-modal');
        const modalSpinner = document.getElementById('modal-spinner');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const modalButtons = document.getElementById('modal-buttons');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const searchInput = document.getElementById('search-input');
        const filterButtons = document.querySelectorAll('.filter-btn');
        const recentlyWatchedContainer = document.getElementById('recently-watched-container');
        const recentlyWatchedSection = document.getElementById('recently-watched-section');
        const galleryTitle = document.getElementById('gallery-title');
        
        // Player-spezifische Elemente
        const progressBar = document.getElementById('progress-bar');
        const currentTimeEl = document.getElementById('current-time');
        const totalDurationEl = document.getElementById('total-duration');

        // Globale Daten
        let mediaItems = JSON.parse(localStorage.getItem('arkivum_media') || '[]');
        let recentlyWatched = JSON.parse(localStorage.getItem('arkivum_watched') || '[]');
        let selectedType = '';
        let mediaData = { title: '', coverFile: null, genres: [], files: [], seasons: [] };
        let currentPlaylist = [];
        let currentEpisodeIndex = 0;
        let draggedItem = null;

        // Hilfsfunktionen zum Speichern der Daten im lokalen Speicher
        function saveMediaItems() {
            // Speichere nur URLs statt ganzer File-Objekte
            const itemsToSave = mediaItems.map(item => {
                const serializableItem = { ...item };
                if (serializableItem.type === 'film') {
                    delete serializableItem.file;
                } else if (serializableItem.type === 'serie') {
                    serializableItem.seasons.forEach(season => {
                        season.files.forEach(fileItem => {
                            delete fileItem.file;
                        });
                    });
                }
                if (serializableItem.coverFile) {
                    delete serializableItem.coverFile;
                }
                return serializableItem;
            });
            localStorage.setItem('arkivum_media', JSON.stringify(itemsToSave));
        }
        
        // Da wir keine File-Objekte direkt speichern können, verwenden wir URL.createObjectURL.
        // Die gespeicherten URLs sind jedoch nach dem Neuladen der Seite ungültig.
        // Um das zu beheben, speichern wir die Datei selbst nicht, sondern nur die Metadaten.
        // Die Dateien müssen bei jedem Neuladen neu hochgeladen werden, oder wir müssen
        // eine serverseitige Lösung verwenden, die hier aber nicht möglich ist.
        // Daher setzen wir mediaItems bei jedem Start auf einen leeren Array.
        // Da die Anforderung "selbst hochladen" lautet, ist dies der beste Weg,
        // um dies in einem lokalen Browser-Speicher zu simulieren, ohne die Dateien
        // dauerhaft zu speichern.
        mediaItems = [];
        localStorage.removeItem('arkivum_media');

        function saveRecentlyWatched() {
            localStorage.setItem('arkivum_watched', JSON.stringify(recentlyWatched));
        }

        // UI-Ansichten wechseln
        function showView(viewId) {
            galleryView.classList.add('hidden');
            addForm.classList.add('hidden');
            videoPlayerView.classList.add('hidden');
            document.getElementById(viewId).classList.remove('hidden');
        }
        
        // Modal-Funktionen für Nachrichten und Ladezustände
        function showModal(message, isSpinner = false, isConfirmation = false) {
            modalMessage.textContent = message;
            modalSpinner.classList.toggle('hidden', !isSpinner);
            modalButtons.classList.toggle('hidden', !isConfirmation);
            modalCloseBtn.classList.toggle('hidden', isSpinner || isConfirmation);
            messageModal.classList.remove('hidden');
        }

        function hideModal() {
            messageModal.classList.add('hidden');
        }
        modalCloseBtn.addEventListener('click', hideModal);
        modalCancelBtn.addEventListener('click', hideModal);

        // UI-Events
        addButton.addEventListener('click', () => {
            mediaForm.reset();
            seriesSection.classList.add('hidden');
            movieFilesSection.classList.add('hidden');
            seasonsContainer.innerHTML = '';
            selectedType = '';
            mediaData = { title: '', coverFile: null, genres: [], files: [], seasons: [] };
            showView('add-form');
        });

        addMovieBtn.addEventListener('click', () => {
            selectedType = 'film';
            seriesSection.classList.add('hidden');
            movieFilesSection.classList.remove('hidden');
            addMovieBtn.classList.remove('bg-gray-700');
            addMovieBtn.classList.add('bg-gray-600');
            addSeriesBtn.classList.remove('bg-gray-600');
            addSeriesBtn.classList.add('bg-gray-700');
        });

        addSeriesBtn.addEventListener('click', () => {
            selectedType = 'serie';
            seriesSection.classList.remove('hidden');
            movieFilesSection.classList.add('hidden');
            addSeriesBtn.classList.remove('bg-gray-700');
            addSeriesBtn.classList.add('bg-gray-600');
            addMovieBtn.classList.remove('bg-gray-600');
            addMovieBtn.classList.add('bg-gray-700');
            // Füge standardmäßig eine Staffel hinzu
            if (seasonsContainer.childElementCount === 0) {
                addSeasonBtn.click();
            }
        });
        
        addSeasonBtn.addEventListener('click', () => {
            const seasonIndex = seasonsContainer.childElementCount;
            const seasonDiv = document.createElement('div');
            seasonDiv.id = `season-${seasonIndex}`;
            seasonDiv.className = 'p-4 bg-gray-700 rounded-lg';
            seasonDiv.innerHTML = `
                <h4 class="font-bold mb-2">Staffel ${seasonIndex + 1}</h4>
                <div class="flex items-center space-x-2 my-2">
                    <label for="file-input-season-${seasonIndex}" class="px-4 py-2 text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-red-600 file:text-white hover:file:bg-red-700 cursor-pointer rounded-full bg-red-600 hover:bg-red-700 text-white">
                        <i class="fas fa-plus mr-1"></i> Episoden hinzufügen
                    </label>
                    <input type="file" id="file-input-season-${seasonIndex}" data-season-index="${seasonIndex}" class="hidden" accept="video/*" multiple>
                </div>
                <p class="text-sm text-gray-400 mb-2">Dateien hierher ziehen, um die Reihenfolge zu ändern.</p>
                <div class="space-y-2 episode-list-container" data-season-index="${seasonIndex}"></div>
            `;
            seasonsContainer.appendChild(seasonDiv);
            mediaData.seasons.push({ name: `Staffel ${seasonIndex + 1}`, files: [] });

            // Neuen Event-Listener für den Dateiupload der neuen Staffel hinzufügen
            document.getElementById(`file-input-season-${seasonIndex}`).addEventListener('change', async (event) => {
                const files = Array.from(event.target.files);
                const sIndex = parseInt(event.target.dataset.seasonIndex);
                if (mediaData.seasons[sIndex]) {
                    const episodeFiles = [];
                    for (const file of files) {
                        const duration = await getDuration(file);
                        episodeFiles.push({ file, duration });
                    }
                    mediaData.seasons[sIndex].files = mediaData.seasons[sIndex].files.concat(episodeFiles);
                    updateEpisodeList(mediaData.seasons[sIndex].files, sIndex);
                }
            });
        });
        
        cancelBtn.addEventListener('click', () => {
            showView('gallery-view');
        });

        backBtn.addEventListener('click', () => {
            playerVideo.pause();
            playerVideo.src = '';
            showView('gallery-view');
        });

        coverInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                mediaData.coverFile = file;
            } else {
                showModal('Bitte wähle eine Bilddatei als Vorschaubild aus.');
                mediaData.coverFile = null;
            }
        });

        fileInputMovie.addEventListener('change', async (event) => {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                const duration = await getDuration(files[0]);
                mediaData.files = [{ file: files[0], duration }];
            }
        });

        // Drag-and-Drop Funktionalität
        seasonsContainer.addEventListener('dragstart', (e) => {
            draggedItem = e.target;
            if (!draggedItem.classList.contains('episode-drag-item')) return;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', null);
            setTimeout(() => { draggedItem.classList.add('opacity-50'); }, 0);
        });

        seasonsContainer.addEventListener('dragend', (e) => {
            if (draggedItem) {
                draggedItem.classList.remove('opacity-50');
                draggedItem = null;
                // Aktualisiere das Datenmodell nach dem Drag-and-Drop
                updateMediaDataFromDOM();
            }
        });

        seasonsContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            const target = e.target.closest('.episode-list-container');
            if (target && draggedItem) {
                const afterElement = getDragAfterElement(target, e.clientY);
                if (afterElement == null) {
                    target.appendChild(draggedItem);
                } else {
                    target.insertBefore(draggedItem, afterElement);
                }
            }
        });

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.episode-drag-item:not(.opacity-50)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function updateMediaDataFromDOM() {
            mediaData.seasons.forEach((season, sIndex) => {
                const seasonElement = document.querySelector(`.episode-list-container[data-season-index="${sIndex}"]`);
                if (seasonElement) {
                    const newFiles = Array.from(seasonElement.children).map(el => {
                        const originalFileIndex = parseInt(el.dataset.originalIndex);
                        const originalSeasonIndex = parseInt(el.dataset.originalSeason);
                        return mediaData.seasons[originalSeasonIndex].files[originalFileIndex];
                    });
                    mediaData.seasons[sIndex].files = newFiles;
                }
            });
        }
        
        // Aktualisiert die Episodenliste im UI
        function updateEpisodeList(files, seasonIndex) {
            const listContainer = document.querySelector(`.episode-list-container[data-season-index="${seasonIndex}"]`);
            if (!listContainer) return;
            listContainer.innerHTML = '';
            files.forEach((fileItem, index) => {
                const item = document.createElement('div');
                item.className = 'bg-gray-800 p-2 rounded-lg flex items-center justify-between text-sm episode-drag-item';
                item.draggable = true;
                item.dataset.originalIndex = mediaData.seasons[seasonIndex].files.indexOf(fileItem);
                item.dataset.originalSeason = seasonIndex;
                item.textContent = `${index + 1}. ${fileItem.file.name}`;
                listContainer.appendChild(item);
            });
        }

        // Ermittelt die Videodauer
        function getDuration(file) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                video.onloadedmetadata = () => {
                    URL.revokeObjectURL(video.src);
                    resolve(Math.round(video.duration)); // Dauer in Sekunden
                };
                video.onerror = () => {
                    URL.revokeObjectURL(video.src);
                    resolve(0); // Bei Fehler 0 zurückgeben
                };
                video.src = URL.createObjectURL(file);
            });
        }

        // Formular absenden
        mediaForm.addEventListener('submit', (event) => {
            event.preventDefault();

            mediaData.title = mediaTitleInput.value;

            if (!mediaData.title || !mediaData.coverFile || (selectedType === 'film' && mediaData.files.length === 0) || (selectedType === 'serie' && mediaData.seasons.length === 0)) {
                showModal('Bitte Titel, Vorschaubild und mindestens eine Datei auswählen.');
                return;
            }
            
            const mediaObject = {
                title: mediaData.title,
                type: selectedType,
                coverUrl: URL.createObjectURL(mediaData.coverFile),
                genres: [], // Genres-Funktion wurde entfernt, kann manuell hinzugefügt werden
                isFavorite: false,
                playbackPosition: 0
            };
            
            if (selectedType === 'film') {
                mediaObject.file = mediaData.files[0].file;
                mediaObject.duration = mediaData.files[0].duration;
            } else if (selectedType === 'serie') {
                mediaObject.seasons = mediaData.seasons.map(season => ({
                    name: season.name,
                    files: season.files.map(item => ({ file: item.file, duration: item.duration }))
                }));
            }

            mediaItems.push(mediaObject);
            // Wir speichern hier nicht im Local Storage, da File-Objekte nicht serialisierbar sind.
            renderAllViews();
            showView('gallery-view');
        });

        // Filter-Funktionalität
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                filterButtons.forEach(btn => {
                    btn.classList.remove('bg-red-600', 'hover:bg-red-700');
                    btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                });
                button.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                button.classList.add('bg-red-600', 'hover:bg-red-700');
                const filter = button.dataset.filter;
                applyFilter(filter);
            });
        });

        function applyFilter(filter) {
            let filteredItems = mediaItems;
            let title = '';
            switch(filter) {
                case 'all':
                    title = 'Alle Medien';
                    recentlyWatchedSection.classList.remove('hidden');
                    break;
                case 'film':
                    filteredItems = mediaItems.filter(item => item.type === 'film');
                    title = 'Filme';
                    recentlyWatchedSection.classList.add('hidden');
                    break;
                case 'serie':
                    filteredItems = mediaItems.filter(item => item.type === 'serie');
                    title = 'Serien';
                    recentlyWatchedSection.classList.add('hidden');
                    break;
                case 'favorites':
                    filteredItems = mediaItems.filter(item => item.isFavorite);
                    title = 'Meine Liste';
                    recentlyWatchedSection.classList.add('hidden');
                    break;
            }
            galleryTitle.textContent = title;
            renderVideoCards(filteredItems);
        }

        // Rendert die "Zuletzt gesehen"-Sektion
        function renderRecentlyWatched() {
            recentlyWatchedContainer.innerHTML = '';
            // Zeige die letzten 6 gesehenen Items
            recentlyWatched.slice(0, 6).forEach(watchedItem => {
                const item = mediaItems.find(media => media.title === watchedItem.title);
                if (item) {
                    const card = document.createElement('div');
                    card.className = 'video-card rounded-lg overflow-hidden bg-gray-800 shadow-xl';
                    
                    let totalDuration = 0;
                    if(item.type === 'film') {
                        totalDuration = item.duration;
                    } else {
                        totalDuration = item.seasons.flatMap(s => s.files).reduce((sum, f) => sum + f.duration, 0);
                    }
                    const progressPercentage = (watchedItem.playbackPosition / totalDuration) * 100;

                    card.innerHTML = `
                        <div class="cover-placeholder bg-gray-700 relative">
                            <img src="${item.coverUrl}" onerror="this.src='https://placehold.co/400x600/1e293b/d1d5db?text=Kein+Cover';" alt="${item.title} Cover" class="cover-image">
                            <div class="title-overlay flex flex-col items-center justify-center">
                                <h3 class="text-sm font-bold truncate text-white">${item.title}</h3>
                                <div class="w-full h-1 bg-gray-500 rounded-full mt-2">
                                    <div class="h-full bg-red-600 rounded-full" style="width: ${progressPercentage}%;"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    card.addEventListener('click', () => {
                        const originalIndex = mediaItems.findIndex(media => media.title === item.title);
                        openPlayer(originalIndex, watchedItem.playbackPosition);
                    });
                    recentlyWatchedContainer.appendChild(card);
                }
            });
            recentlyWatchedSection.classList.toggle('hidden', recentlyWatched.length === 0);
        }
        
        // Galerie-Ansicht rendern, optional mit gefilterten Items
        function renderVideoCards(itemsToRender = mediaItems) {
            videoContainer.innerHTML = '';
            itemsToRender.forEach((item, index) => {
                const originalIndex = mediaItems.findIndex(mediaItem => mediaItem === item);
                const card = document.createElement('div');
                card.className = 'video-card relative rounded-lg overflow-hidden bg-gray-800 shadow-xl';
                
                const icon = item.type === 'serie' ? 'fa-tv' : 'fa-film';

                card.innerHTML = `
                    <button class="delete-btn" data-index="${originalIndex}">
                        <i class="fas fa-trash"></i>
                    </button>
                    <button class="favorite-btn" data-index="${originalIndex}">
                        <i class="${item.isFavorite ? 'fas' : 'far'} fa-heart" style="color: ${item.isFavorite ? '#e50914' : 'white'};"></i>
                    </button>
                    <div class="cover-placeholder bg-gray-700 relative">
                        <img src="${item.coverUrl}" onerror="this.src='https://placehold.co/400x600/1e293b/d1d5db?text=Kein+Cover';" alt="${item.title} Cover" class="cover-image">
                        <div class="title-overlay flex items-end justify-center">
                            <h3 class="text-sm font-bold truncate text-white">${item.title}</h3>
                        </div>
                    </div>
                    <div class="p-4">
                        <p class="text-xs text-gray-400 mt-1">${item.genres.join(', ') || (item.type === 'serie' ? 'Serie' : 'Film')}</p>
                    </div>
                `;
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.delete-btn') && !e.target.closest('.favorite-btn')) {
                        openPlayer(originalIndex);
                    }
                });
                videoContainer.appendChild(card);
            });
        }

        // Funktion zum Löschen eines Elements
        function deleteMediaItem(index) {
            mediaItems.splice(index, 1);
            saveMediaItems();
            renderAllViews();
        }
        
        // Suche nach Titeln
        searchInput.addEventListener('keyup', (event) => {
            const query = event.target.value.toLowerCase();
            const filteredItems = mediaItems.filter(item =>
                item.title.toLowerCase().includes(query)
            );
            renderVideoCards(filteredItems);
        });

        // Event-Delegation für den Lösch- und Favoriten-Button
        videoContainer.addEventListener('click', (e) => {
            const deleteBtn = e.target.closest('.delete-btn');
            const favoriteBtn = e.target.closest('.favorite-btn');

            if (deleteBtn) {
                const index = deleteBtn.dataset.index;
                const title = mediaItems[index].title;
                showModal(`Möchtest du "${title}" wirklich löschen?`, false, true);
                modalConfirmBtn.onclick = () => {
                    deleteMediaItem(index);
                    hideModal();
                };
            }
            
            if (favoriteBtn) {
                const index = favoriteBtn.dataset.index;
                mediaItems[index].isFavorite = !mediaItems[index].isFavorite;
                saveMediaItems();
                renderAllViews();
            }
        });


        // Player-Ansicht öffnen und Videos abspielen
        function openPlayer(mediaIndex, startTime = 0) {
            const item = mediaItems[mediaIndex];
            playerTitle.textContent = item.title;

            // Zuletzt gesehen aktualisieren
            const existingWatched = recentlyWatched.find(i => i.title === item.title);
            if (existingWatched) {
                recentlyWatched = recentlyWatched.filter(i => i.title !== item.title);
            }
            recentlyWatched.unshift({ title: item.title, playbackPosition: startTime, type: item.type });
            saveRecentlyWatched();
            
            if (item.type === 'film') {
                currentPlaylist = [{ file: item.file }];
                currentEpisodeIndex = 0;
                playerSubtitle.textContent = ``;
                playCurrentEpisode(startTime);
            } else if (item.type === 'serie') {
                currentPlaylist = item.seasons.flatMap(s => s.files);
                currentEpisodeIndex = 0;
                // Finde die richtige Episode basierend auf der gespeicherten Position
                const totalDuration = currentPlaylist.reduce((sum, f) => sum + f.duration, 0);
                
                let cumulativeDuration = 0;
                for(let i = 0; i < currentPlaylist.length; i++) {
                    const episodeDuration = currentPlaylist[i].duration;
                    if(startTime < cumulativeDuration + episodeDuration) {
                        currentEpisodeIndex = i;
                        const episodeStartTime = startTime - cumulativeDuration;
                        playCurrentEpisode(episodeStartTime);
                        break;
                    }
                    cumulativeDuration += episodeDuration;
                }
            }
            showView('video-player-view');
        }

        // Speichert den Wiedergabefortschritt und aktualisiert den Fortschrittsbalken
        playerVideo.addEventListener('timeupdate', () => {
            const item = mediaItems.find(media => media.title === playerTitle.textContent);
            if (item) {
                const watchedItem = recentlyWatched.find(i => i.title === item.title);
                if (watchedItem) {
                    watchedItem.playbackPosition = playerVideo.currentTime;
                    saveRecentlyWatched();
                }
            }

            const totalDuration = playerVideo.duration;
            const currentTime = playerVideo.currentTime;
            const progressPercentage = (currentTime / totalDuration) * 100;
            progressBar.style.width = `${progressPercentage}%`;
            
            currentTimeEl.textContent = formatTime(currentTime);
            if (totalDuration) {
                 totalDurationEl.textContent = formatTime(totalDuration);
            }
        });

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        }

        // Spielt die aktuelle Episode ab und geht zur nächsten
        function playCurrentEpisode(startTime = 0) {
            if (currentEpisodeIndex < currentPlaylist.length) {
                const episode = currentPlaylist[currentEpisodeIndex];
                const videoUrl = URL.createObjectURL(episode.file);
                playerVideo.src = videoUrl;
                
                // Update subtitle for series
                const seriesItem = mediaItems.find(item => item.title === playerTitle.textContent && item.type === 'serie');
                if (seriesItem) {
                    let episodeNumber = 1;
                    let seasonNumber = 1;
                    let cumulativeEpisodes = 0;
                    for (let s of seriesItem.seasons) {
                        for (let e of s.files) {
                            if (cumulativeEpisodes === currentEpisodeIndex) {
                                playerSubtitle.textContent = `Staffel ${seasonNumber} | Episode ${episodeNumber}`;
                                break;
                            }
                            cumulativeEpisodes++;
                            episodeNumber++;
                        }
                        if (cumulativeEpisodes > currentEpisodeIndex) break;
                        seasonNumber++;
                        episodeNumber = 1;
                    }
                } else {
                    playerSubtitle.textContent = ``;
                }
                
                playerVideo.onloadedmetadata = () => {
                    playerVideo.currentTime = startTime;
                    playerVideo.play();
                };

                playerVideo.onended = () => {
                    currentEpisodeIndex++;
                    playCurrentEpisode(0); // Starte die nächste Episode bei 0
                };
            } else {
                showModal('Ende der Wiedergabeliste erreicht.', false);
                backBtn.click();
            }
        }
        
        // Rendert alle Sektionen neu
        function renderAllViews() {
            renderRecentlyWatched();
            renderVideoCards();
        }

        // Initiales Rendern
        renderAllViews();
        
    </script>
</body>
</html>
